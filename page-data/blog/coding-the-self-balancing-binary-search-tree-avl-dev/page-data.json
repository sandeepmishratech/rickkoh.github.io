{
    "componentChunkName": "component---src-pages-blog-markdown-remark-frontmatter-path-js",
    "path": "/blog/coding-the-self-balancing-binary-search-tree-avl-dev/",
    "result": {"data":{"markdownRemark":{"id":"61d5d00f-62a7-5dc1-94b5-6a980d8c2b79","html":"<h2>Description</h2>\n<p><img src=\"/./src/posts/7c5ad575abcc897fc667d2bf986cbc08/avl.jpg\" alt=\"img\">\r\nAn AVL is a BST (Binary Search Tree) that balances itself. Such a tree is mainly used for archiving functionalities when data retrieval is prioritized over data manipulation. The worst case it will consume is <strong>O(log n)</strong> as it constantly rebalances itself; compared to a BST which will take O(n), assuming that you insert the items incrementally (e.g. 1 -> 2 -> 3 -> 4 …).\r\n<br>\n<br>\nIn this blog, I will be coding a C++ console application that demonstrates how an AVL tree balances itself and display the different traversals step by step to understand how the AVL tree works.</p>\n<h2>Functionalities</h2>\n<ol>\n<li>Adding a node to the tree.</li>\n<li>Removing a node from the tree.</li>\n<li>Displaying path of a value in the tree.</li>\n<li>Displaying values in an ascending order.</li>\n<li>Displaying the value of the node given a position using level-by-level traversal.</li>\n<li>(Bonus) Displaying the tree in a 2D format in the console!</li>\n</ol>\n<p>The full source code can be found here.\r\n<br>\n<br>\n<a href=\"https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66\"><a href=\"https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66\">https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66</a></a>\r\n<br>\n<br>\nAlternatively you can live demo it here.\r\n<br>\n<br>\n<a href=\"https://onlinegdb.com/dQycYdSxb\"><a href=\"https://onlinegdb.com/dQycYdSxb\">https://onlinegdb.com/dQycYdSxb</a></a></p>\n<h2>Starting with Rotations</h2>\n<h3>Balanced or unbalanced</h3>\n<blockquote>\n<p>Not all BST are AVL but all AVL are BST. The difference is that an <strong>AVL is a balanced BST</strong> while a BST can be either balanced or unbalanced.</p>\n</blockquote>\n<p><img src=\"/./src/posts/bf3be37493b65609d45d636f73a7c46f/balanced-vs-unbalanced.jpg\" alt=\"img\">\r\nTo determine if the BST is balanced, we check whether the <strong>balance factor</strong> is more than 1 or less than -1, where the balance factor is = height of the left subtree - height of the right subtree.\r\n<br>\n<br>\n<img src=\"/./src/posts/191ec58917b1f8c65e57d13a57e3dd1c/balance-factor.jpg\" alt=\"img\">\r\nTo calculate the height of the tree, we use a recursion function to iterate through each layer of the tree. The base case is if the node is NULL which indicates that it has reached the bottom of the tree.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">int balanceFactor(BinaryNode* t)\r\n{\r\n    if (t != NULL)\r\n        return getHeight(t-&gt;left) - getHeight(t-&gt;right);\r\n    else\r\n        return 0;\r\n}\r\n\r\nint getHeight()\r\n{\r\n    return getHeight(root);\r\n}\r\nint getHeight(BinaryNode* t)\r\n{\r\n    if (t == NULL)\r\n        return 0;\r\n    else\r\n    {\r\n        int leftHeight = getHeight(t-&gt;left);\r\n        int rightHeight = getHeight(t-&gt;right);\r\n        if (leftHeight &gt; rightHeight)\r\n            return leftHeight + 1;\r\n        else\r\n            return rightHeight + 1;\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>The 4 different rotations</h3>\n<p><strong>Left Rotation</strong> Starting with the Left Rotation. This rotation is required when the right subtree is heavier than the left subtree. To execute the Left Rotation, it moves every node from the right to the left.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">1                    2\r\n  \\                /   \\\r\n    2      =&gt;    1       3\r\n      \\\r\n        3\r\n\r\nBinaryNode* rotateLeft(BinaryNode* &amp;t)\r\n{\r\n    BinaryNode* tempNode = t-&gt;right;\r\n    t-&gt;right = tempNode-&gt;left;\r\n    tempNode-&gt;left = t;\r\n    return tempNode;\r\n}</code>\n        </deckgo-highlight-code>\n<p><strong>Right Rotation</strong> The second type of rotation is the Right Rotation. This rotation is similar to the Left Rotation but is required when the left subtree is heavier than the right subtree. To execute the Right Rotation, it moves every node from the left to the right.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">        3            2\r\n      /            /   \\\r\n    2      =&gt;    1       3\r\n  /    \r\n1        \r\n\r\nBinaryNode* rotateRight(BinaryNode* &amp;t)\r\n{\r\n    BinaryNode* tempNode = t-&gt;left;\r\n    t-&gt;left = tempNode-&gt;right;\r\n    tempNode-&gt;right = t;\r\n    return tempNode;\r\n}</code>\n        </deckgo-highlight-code>\n<p><strong>Left Right Rotation</strong> The third type of rotation is the Left Right Rotation. This rotation will occur when the left node is heavier than the right node with the addition that left node's right subtree is heavier than left node's left subtree. To execute the Left Right Rotation, it will perform a Left Rotation and followed by a Right Rotation.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">      5                       3\r\n    /   \\                   /   \\\r\n  2       6      =&gt;       2       5\r\n /  \\                   /        /  \\    \r\n1     3               1        4      6     \r\n        \\                              \r\n          4                              \r\n\r\nBinaryNode* rotateLeftRight(BinaryNode* &amp;t)\r\n{\r\n    BinaryNode* tempNode = t-&gt;left;\r\n    t-&gt;left = rotateLeft(tempNode);\r\n    return rotateRight(t);\r\n}</code>\n        </deckgo-highlight-code>\n<p><strong>Right Left Rotation</strong> The last type of rotation is the Right Left Rotation. This rotation will occur when the right node is heavier than the left node with the addition that the right node's left subtree is heavier than the right node's right subtree. To execute the Right Left Rotation, it will perform a Right Rotation followed by a Left Rotation.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">     2                       4\r\n   /   \\                   /   \\\r\n 1       5      =&gt;       2       5\r\n        / \\            /   \\       \\\r\n      4     6        1       3       6\r\n     /       \r\n    3         \r\n\r\nBinaryNode* rotateRightLeft(BinaryNode* &amp;t)\r\n{\r\n    BinaryNode* tempNode = t-&gt;right;\r\n    t-&gt;right = rotateRight(tempNode);\r\n    return rotateLeft(t);\r\n}</code>\n        </deckgo-highlight-code>\n<h3>Balance</h3>\n<p>To recap the different cases for each rotation\r\n<br>\n<br>\n<strong>Right heavy</strong> = Left Rotation (L)\r\n<br>\n<br>\n<strong>Left heavy</strong> = Right Rotation (R)\r\n<br>\n<br>\n<strong>Left heavy with a heavier right subtree</strong> = Left Right Rotation (LR)\r\n<br>\n<br>\n<strong>Right heavy with a heavier left subtree</strong> = Right Left Rotation (RL)</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">BinaryNode* balance(BinaryNode* &amp;t)\r\n{\r\n    if (root == NULL)\r\n        return NULL;\r\n    else if (balanceFactor(t) == 2)              // left heavy\r\n    {\r\n        if (balanceFactor(t-&gt;left) &lt;= -1)        // right subtree heavier\r\n        {\r\n            cout &lt;&lt; &quot;Left Right Rotated&quot; &lt;&lt; endl;\r\n            t = rotateLeftRight(t);\r\n        }\r\n        else\r\n        {\r\n            cout &lt;&lt; &quot;Right Rotated&quot; &lt;&lt; endl;\r\n            t = rotateRight(t);\r\n        }\r\n    }\r\n    else if (balanceFactor(t) == -2)             // right heavy\r\n    {\r\n        if (balanceFactor(t-&gt;right) &gt;= 1)        // left subtree heavier\r\n        {\r\n            cout &lt;&lt; &quot;Right Left Rotated&quot; &lt;&lt; endl;\r\n            t = rotateRightLeft(t);\r\n        }\r\n        else\r\n        {\r\n            cout &lt;&lt; &quot;Left Rotated&quot; &lt;&lt; endl;\r\n            t = rotateLeft(t);\r\n        }\r\n    }\r\n    return NULL;\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Insertion</h2>\n<p>The insertion function will be using recursion as the tree has to trace back and balance itself upon insertion. The base case for this function is (1) if the node is NULL or (2) if the item is found. If the node is NULL, that means that the item does not exist within the tree, hence we will create a new node with the new value and replace the NULL node with the new node. If the node is found, it will print “Item already exists”.\r\n<br>\n<br>\nFor the recursion, it will traverse down the tree either to the left (item smaller than node’s item) or to the right (item larger than node’s item) until it reaches the base case. Once it is at the base case, it will trace back and balance the tree.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">void insert(ItemType item)\r\n{\r\n    insert(root, item);\r\n}\r\nvoid insert(BinaryNode* &amp;t, ItemType item)\r\n{\r\n    if (t == NULL)\r\n    {\r\n        BinaryNode *newNode = new BinaryNode;\r\n        newNode-&gt;item = item;\r\n        newNode-&gt;left = NULL;\r\n        newNode-&gt;right = NULL;\r\n        t = newNode;\r\n        cout &lt;&lt; &quot;Item added successfully.&quot; &lt;&lt; endl;\r\n    }\r\n    else\r\n        if (item &lt; t-&gt;item)\r\n            insert(t-&gt;left, item);\r\n        else if (item &gt; t-&gt;item)\r\n            insert(t-&gt;right, item);\r\n        else\r\n            cout &lt;&lt; &quot;Item already exists.&quot; &lt;&lt; endl;\r\n    balance(t);\r\n}</code>\n        </deckgo-highlight-code>\n<p>The code optimization for this function is O(logN), as every time it traverses, the number of items it needs to compare is divided by half.</p>\n<h2>Deletion</h2>\n<p>The deletion function will be using recursion as the tree has trace back and balance itself upon deletion. The base case for this function is (1) if the target node is found or (2) if the target node cannot be found.\r\n<br>\n<br>\n<strong>Case 1 (node doesn’t exist)</strong>\r\nIf the node does not exist, we will print “Item does not exist.”.\r\n<br>\n<br>\n<strong>Case 2 (no children)</strong>\r\nWe can identify whether it has any children by checking if the left and right of the current node is NULL. Once identified, we will set the parent left or right node to NULL with respect to whether it is a left or right child. Else if the node is root, we will set the root to NULL directly.\r\n<br>\n<br>\n<strong>Case 3 (one child)</strong>\r\nWe can identify whether it only has one child by checking if one of its children is NULL. Once identified, we will set the parent’s right or left node to its child node respectively.\r\n<br>\n<br>\n<strong>Case 4 (two children)</strong>\r\nThe third case is if the node has two children. To do that, we will need to find a successor to replace the current node. The successor will be the next biggest value closest to the current node. Once the successor has been found, we will replace the value of the current node with the successor’s value and then delete the original successor node.\r\n<br>\n<br>\n<strong>Case 5 (hasn’t reached the bottom)</strong>\r\nIf we haven’t reached the bottom, we will continue to traverse down the tree by iterating the function. The bottom can be identified if the node is == NULL, as that means that there are more nodes to compare.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">void remove(ItemType target)\r\n{\r\n    remove(root, target, NULL, false);\r\n}\r\nvoid remove(BinaryNode* &amp;t, ItemType target, BinaryNode* parent, bool isLeftChild)\r\n{\r\n    if (t == NULL)                                      // base case\r\n    {\r\n        cout &lt;&lt; &quot;Item does not exist.&quot; &lt;&lt; endl;\r\n    }\r\n    else if (target == t-&gt; item) {\r\n        if (t-&gt;left == NULL &amp;&amp; t-&gt;right == NULL) {      // its a leaf\r\n            if (t == root)\r\n                root = NULL;\r\n            else\r\n                if (isLeftChild)\r\n                    parent-&gt;left = NULL;\r\n                else\r\n                    parent-&gt;right = NULL;\r\n        }\r\n        else if (t-&gt;left == NULL) {                     // has right leaf\r\n            if (t == root)\r\n                t = t-&gt;right;\r\n            else if (isLeftChild)\r\n                parent-&gt;left = t-&gt;right;\r\n            else\r\n                parent-&gt;right = t-&gt;right;\r\n        }\r\n        else if (t-&gt;right == NULL) {                    // has left leaf\r\n            cout &lt;&lt; isLeftChild &lt;&lt; endl;\r\n            if (t == root)\r\n                t = t-&gt;left;\r\n            else if (isLeftChild)\r\n                parent-&gt;left = t-&gt;left;\r\n            else\r\n                parent-&gt;right = t-&gt;left;\r\n        }\r\n        else {                                          // has two leafs\r\n            BinaryNode* temp = t;\r\n            BinaryNode* successor = t-&gt;left;\r\n            while (successor-&gt;right != NULL)\r\n                successor = successor-&gt;right;\r\n            int n = successor-&gt;item;\r\n            remove(t, n, NULL, true);\r\n            temp-&gt;item = n;\r\n        }\r\n        cout &lt;&lt; &quot;Item removed successfully.&quot; &lt;&lt; endl;\r\n    }\r\n    else {\r\n        if (target &lt; t-&gt;item) {\r\n            remove(t-&gt;left, target, t, true);\r\n        } else {\r\n            remove(t-&gt;right, target, t, false);\r\n        }\r\n    }\r\n    balance(t);\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Display path of a value in the tree</h2>\n<p><img src=\"/./src/posts/ae94d6fd8d6238dfeb65c5cffb9e98f5/find-node.jpg\" alt=\"img\">\r\nThis function will be using recursion as well as we will be traversing down the tree layer by layer to search for the value.</p>\n<p>The base case of this function will be (1) if the item is found or (2) if we reached the bottom of the tree. If not, we will continue to traverse down the tree by comparing  if the value we are searching for is greater or lesser than the current node’s value.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">string displayPathOfValue(ItemType target)\r\n{\r\n    string route;\r\n    route = &quot;Root &quot;;\r\n    return displayPathOfValue(root, target, route);\r\n}\r\nstring displayPathOfValue(BinaryNode* t, ItemType target, string route)\r\n{\r\n    if (t == NULL)\r\n        return route + &quot;not found&quot;;\r\n    else if (t-&gt;item == target)\r\n        return route + to_string(t-&gt;item) + &quot; found&quot;;\r\n    else {\r\n        if (target &lt; t-&gt;item)\r\n        {\r\n            route += to_string(t-&gt;item) + &quot; L &quot;;\r\n            return displayPathOfValue(t-&gt;left, target, route);\r\n        }\r\n        else\r\n        { \r\n            route += to_string(t-&gt;item) + &quot; R &quot;;\r\n            return displayPathOfValue(t-&gt;right, target, route);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Displaying values in an ascending order</h2>\n<p>To display the values in an ascending order, we will want to display the values starting from the bottom left, followed by its immediate parent, and then repeat from the left to the right until all the values are displayed.</p>\n<p>There will be no base case for this function as it is tail recursive. The condition to stop the function is if the node it checks is NULL.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">void displayInAscending() {\r\n    if (isEmpty())\r\n        cout &lt;&lt; &quot;No item found&quot; &lt;&lt; endl;\r\n    else\r\n        displayInAscending(root);\r\n}\r\nvoid displayInAscending(BinaryNode* t) {\r\n    if (t != NULL) {\r\n        displayInAscending(t-&gt;left);\r\n        cout &lt;&lt; t-&gt;item &lt;&lt; endl;\r\n        displayInAscending(t-&gt;right);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Displaying the value of the node given a position using level-by-level traversal</h2>\n<p>For this function we will leverage on <a href=\"https://www.geeksforgeeks.org/queue-data-structure/\">Queue</a> to traverse thorugh the nodes level by level, starting from the top (root), and then traverse down layer by layer, from the left to the right using the FIFO method. The position, otherwise known as counter, will decrease by 1 for each traversal we take, hence finding the value of the node given a position.\r\n<br>\n<br>\nThe base case will be (1) if the node is null, that means we have traversed through their entire tree and the counter hasn’t finished counting, or (2) if the counter reaches 0, which means we have found the position we are looking for, hence we return the value.\r\n<br>\n<br>\nAfter checking each value, we will enqueue the left and right node respectively and then dequeue the front node after traversing it.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">int getValueofPosition(int counter)\r\n{\r\n    Queue q;\r\n    q.enqueue(root);\r\n    return getValueofPosition(q, counter-1);\r\n}\r\nint getValueofPosition(Queue q, int counter)\r\n{\r\n    BinaryNode* parent = q.getFront();\r\n    if (parent == NULL)\r\n    {\r\n        return 0;\r\n    }\r\n    if (counter == 0)\r\n        return parent-&gt;item;\r\n    else\r\n    {\r\n        if (parent-&gt;left != NULL)\r\n            q.enqueue(parent-&gt;left);\r\n        if (parent-&gt;right != NULL)\r\n            q.enqueue(parent-&gt;right);\r\n        q.dequeue();\r\n        counter--;\r\n        return getValueofPosition(q, counter);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Displaying the tree in a 2D format</h2>\n<p>To print the tree in a 2D format, we need to determine the amount of space required to print on the left and right side of the node.</p>\n<p><img src=\"/./src/posts/4afd0a9a0bae9a73d7be4f74ee197bb5/pyramid.jpg\" alt=\"img\">\r\nFrom the image, we can see that the amount of space we require to print is divided by half every time we travel down the tree. If we reverse it, the number of spaces we require to print everytime we travel up would double.</p>\n<p>Hence, we can derive that the amount of space required = 2 ^ height-1.\r\nWe minus 1 from the height as we want to start our count from 0.</p>\n<p>For example,\r\n<br>\n<br>\nHeight = 1, Spaces = 2 ^ (1-1) = 1\r\n<br>\n<br>\nHeight = 2, Spaces = 2 ^ (2-1) = 2\r\n<br>\n<br>\nHeight = 3, Spaces = 2 ^ (3-1) = 4\r\n<br>\n<br>\nHeight = 4, Spaces = 2 ^ (4-1) = 8</p>\n<p>Additionally, some digits would require more space. For example any number that comprises 2 digits (such as ‘14’) would require 2 spaces while single digit numbers (such as ‘3’) would require only 1 space. To overcome this, we can determine the number of spaces to push back using the formula log10(x), where x is = value of digit.</p>\n<p>log10(1) = 0\r\n<br>\n<br>\nlog10(10) = 1\r\n<br>\n<br>\nlog10(100) = 2</p>\n<p>To print the tree, we will print from the top to the bottom. To print each layer, we will use a for loop and determine the amount of space and parse that value to the next function which will print the level.\r\n<br>\n<br>\n<strong>Base case</strong> If we have reached the target level, we will print the values followed by the number of spaces\r\n<br>\n<br>\n<strong>If not</strong> We will parse the value and iterate to the next level</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">void printTree()\r\n{\r\n    // print level by level\r\n    for (int level = 0; level &lt; getHeight(root); level++)\r\n    {\r\n        printLevel(level);\r\n        cout &lt;&lt; endl;\r\n    }\r\n}\r\nvoid printLevel(int target)\r\n{\r\n    BinaryNode* tempNode = root;\t\t\t\t\t\t\t\t\r\n    // calculate space\r\n    int space = pow(2, getHeight(root) - target);\r\n    cout &lt;&lt; setw(space);\r\n    printLevel(tempNode, target, space);\r\n}\r\nvoid printLevel(BinaryNode* t, int target, int space)\t\t\r\n{\r\n    int spaces = 2 * space;\r\n    if (target == 0)\r\n        if (t == NULL)\r\n            cout &lt;&lt; &quot; &quot; &lt;&lt; setw(spaces - 1) &lt;&lt; &quot;&quot;;\r\n        else\r\n        {\r\n            // take account some digits require more space\r\n            int pushedback = ((t-&gt;item &lt;= 1) ? 1 : log10(t-&gt;item) + 1);\t\r\n            cout &lt;&lt; &quot; &quot; &lt;&lt; t-&gt;item &lt;&lt; &quot; &quot;;\r\n            cout &lt;&lt; setw(spaces - pushedback - 2) &lt;&lt; &quot;&quot;;\r\n        }\r\n    else {\r\n        if (t == NULL &amp;&amp; target &gt;= 1)\r\n        {\r\n            printLevel(NULL, target - 1, space);\r\n            printLevel(NULL, target - 1, space);\r\n        }\r\n        else\r\n        {\r\n            printLevel(t-&gt;left, target - 1, space);\r\n            printLevel(t-&gt;right, target - 1, space);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>Done</h3>\n<p><img src=\"/./src/posts/d97b88e01c33b2b05856f38efe885493/done.jpg\" alt=\"img\">\r\nThe full source code can be found here\r\n<br>\n<br>\n<a href=\"https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66\"><a href=\"https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66\">https://gist.github.com/rickkoh/e286114ef189cca283ab20d696d65f66</a></a>\r\n<br>\n<br>\nAlternatively you can live demo it here\r\n<br>\n<br>\n<a href=\"https://onlinegdb.com/dQycYdSxb\"><a href=\"https://onlinegdb.com/dQycYdSxb\">https://onlinegdb.com/dQycYdSxb</a></a>\r\n<br>\n<br>\n- Rick</p>","frontmatter":{"title":"Coding the self balancing binary search tree (AVL)","date":"September 16, 2021"}}},"pageContext":{"id":"61d5d00f-62a7-5dc1-94b5-6a980d8c2b79","frontmatter__path":"coding-the-self-balancing-binary-search-tree-avl-dev","__params":{"frontmatter__path":"coding-the-self-balancing-binary-search-tree-avl-dev"}}},
    "staticQueryHashes": []}